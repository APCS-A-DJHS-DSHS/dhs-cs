<html><head>   <title>Mini-Lab: ArrayLists</title>   <LINK REL=STYLESHEET TYPE="text/css" HREF="aquaLabs.css"></head><body><!--#include file="siteTitle.html" --><DIV ID=pageTitle><h1>Mini-Lab:More Fish!</h1><p><strong>Using ArrayLists</strong></DIV><p><!--#include file="author.html" --><p><HR><p>This set of Mini-Lab Exercises is the fourth in a series in which studentsbuild a small program with several fish moving around in an aquarium.The set includes the following exercises:	<ul>	<li><a href="#LIDS">Becoming a Collector</a> &nbsp;&nbsp;&nbsp;		(Patterns: <strong>Linear Indexed Data Structure</strong>		and		<strong>Expandable Linear Indexed Data Structure</strong>)	  <li><a href="#AppendFish">Let's Go Fishing</a>&nbsp;&nbsp;&nbsp; (Patterns:     <strong>Appended Item</strong>)   <li><a href="#AccessFish">Viewing the Catch</a>&nbsp;&nbsp;&nbsp;		(Patterns: <strong>Indexed Random Access</strong> and		<strong>Valid Index</strong>)	<li><a href="#ProcessAll">Loopy Fish</a> &nbsp;&nbsp;&nbsp;		(Pattern: <strong>Linear Indexed Traversal</strong>)	<li><a href="#School in Motion">A School in Motion</a>		&nbsp;&nbsp;&nbsp;	</ul><p>Each section contains an <strong>Introduction</strong> to a problemor task, (usually) abridged versions of one or more<strong>Patterns</strong> that will be useful in solving the problem orcompleting the task, and an <strong>Exercise</strong>.<p>In the exercises that precede this one, students will have created threefish that move randomly back and forth in an aquarium,being careful not to hit the sides. Students should be familiar with basicfor loops, simple selection statements, prompting for input, and the<a href="Code/JavaDocs/TempRandom.html">Random class</a>.<p>Students should read over the patterns that appear in thisdocument before the lab.<p><HR><HR><p><a NAME="LIDS"></a><H2>Becoming a Collector</H2><p><h3>Introduction</h3>A more realistic simulation of an aquarium would have more than two or three fish. We could modify the simulation so that it supports four fish, five fish, or twelve fish in that many variables, but if we "hard-code" the number of fish into the program in this way, then we must modify and re-compile the program to change the number of fish in the aquarium. We must also repeat statements, such as the code to display and move fish, four, five, or twelve times. <p>A better alternative would be to ask the user how many fish to placein the aquarium and then store them in a collection object. We can usea <strong>Linear Indexed Data Structure</strong> to store thecollection of fish.<ul>  <a NAME="LinIndDS"></a>   <h3><strong>Pattern: Linear Indexed Data Structure</strong> (Container) -- Abridged</h3>  You are in a situation in which you need a collection of objects of a given   type, such that at least one of the following conditions is true.   <!-- You want to write simply understood code. -->  <ul>    <li> You will want to be able to access arbitrary elements in the collection       quickly. (For example, you might want to directly and quickly access the       5th element in the collection without stepping through the first 4 elements.)     <li> The order of the elements in the collection is unimportant.     <li> The order of the elements in the collection is important and elements       will be added to the collection in order.       <blockquote> <i>See the complete <a href="/patterns/LinearIndexDS.shtml#LinIndDS">Linear         Indexed Data Structure pattern</a> to see other conditions in which this         pattern is appropriate.</i> </blockquote>      <!--    <li>The order of the elements in the collection is important,	    elements will not necessarily be added in the proper order,	    but all elements could be added to the collection and	    rearranged into the proper order before any other processing	    takes place.    <li>The order of the elements in the collection is important,	    elements will not necessarily be added in the proper order	    but each element's proper order can be deduced from	    information about the element itself (without reference to	    the other elements in the collection) and all elements will	    be added to the collection and before any other processing	    takes place.-->  </ul>  <!--<p>A Linear Indexed Data Structure might not be the best choice if<ul>    <li>The order of the elements in the collection is important but	    elements will not be added to the collection in order	    (especially if elements may be added to the collection as	    you are processing it, rather than all at the start).    <li>You will always access elements in the collection in order		(from first to last or last to first).    <li>the ordering is important, but objects will not be added to		the collection in the order in which they will be		accessed and the location of objects in the order is		dependent on the other objects in the collection		(But you could still use a linear indexed data		structure, reordering the objects after they are all		added to the collection, if all (or nearly all) objects		are added to the collection before the alternative		ordering is needed.)</ul>See <a href="#LinLinkDS">Linear Linked Data Structure</a> or otheralternatives in the complete<a href="/patterns/LinearIndexDS.shtml">LinearIndexed Data StructurePattern</a> for other possible data structures.-->  <p> <strong>Therefore</strong>, use a <strong>Linear Indexed Data Structure</strong>.     Examples include the Java <code>ArrayList</code> class, Java <code>String</code>,     or a built-in array. Patterns for building and using these structures include     <a href="#ExpandableLinDS">Expandable Linear Indexed Data Structure</a>, <a href="#Append">Appended     Item</a>, and <a href="#LinIndTrav">Linear Indexed Traversal</a>.   <p>   <hr WIDTH="80%">  <p> <a NAME="ExpandableLinDS"></a>   <h3><strong>Pattern: Expandable Linear Indexed Data Structure</strong> (Linear     Indexed Data Structure) -- Abridged</h3>  You are in a situation that calls for a <strong>Linear Indexed Data Structure</strong>   and you don't know up front how many objects it will need to hold.   <p> <strong>Therefore</strong>, declare and construct an empty collection, using     the <a href="/patterns/Variables.shtml#DCI">Declare-Construct-Initialize</a>     pattern. Add <a href="#Append">Appended Items</a> to the collections as necessary,     using a method that resizes the collection automatically.   <p> For example, the syntax for creating a Java <code>ArrayList</code> is:   <ul>    <pre><code>ArrayList v = new ArrayList();</code></pre>  </ul>  <p> These patterns are described more fully in the complete <a href="/patterns/LinearIndexDS.shtml">Linear     Indexed Data Structure Pattern</a>. </ul><p><center><table width="90%" border=1><tr><td><H4>Exercise</H4>        <p>		<ul>          <li>Replace the three fish you constructed earlier with an <a href="#ExpandableLinDS">Expandable             Linear Indexed Data Structure</a> (which doesn't yet have any fish).             What does this data structure represent? Choose a <strong>Intention             Revealing Name</strong> for it. Don't forget to import the appropriate             library class (<code>java.util.</code><code>ArrayList</code>).             <hr WIDTH="90%">            <p> It is always difficult to test modified code part-way through               the change. At this point, you have constructed an expandable collection               that can contain three fish in the future. You no longer have three               fish, but the rest of your program still expects three named fish.               In order to test that you have not introduced any syntax errors               into your program, "comment out" the code that displays and moves               the three fish (who no longer exist). Do this by placing the specified               code in comments. For example,             <ul>              <pre><code>/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.showFish (fish1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; <i>more code to display and move fish</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.showFish (fish3);*/</code></pre>            </ul>            Now compile your program just to make sure that you have created your             expandable collection correctly. (Don't be surprised when your program             no longer moves or displays fish!)         </ul></td></tr></table></center><p><HR><HR><p><a NAME="AppendFish"></a><H2>Let's Go Fishing</H2><p><h3>Introduction</h3>Of course, we don't see any fish, because we haven't created any.&nbsp; But we do have a container to hold them.&nbsp; When we create fish, we can put them directly into the Linear Indexed Data Structure as <strong>Appended Items</strong>. <ul>  <a NAME="Append"></a>   <h3><strong>Pattern: Appended Item</strong> (Linear Indexed Data Structure)     -- Abridged</h3>  <p> You want to add an element to an <a href="#ExpandableLinDS">Expandable Linear     Indexed Data Structure</a>. Either you don't care where in the list the item     is put, or you want to add it as the last item.   <p> <strong>Therefore</strong>, use a method that will append an object to the     end of the collection.   <p> For example, if <code>deck</code> is a Java <code>ArrayList</code> of playing     cards, then the following statement adds a new <code>Card</code> to the end     of the deck:   <ul>    <pre><code>deck.add(new Card());</code></pre>  </ul>  Notice that it is not necessary to create a new variable for each element in   the collection. We refer to the individual object by specifying its location   using <a href="#IndRanAcc">Indexed Random Access</a> rather than by using a   unique variable name.   <p> Of course, it is also possible to append an already existing object to a     collection.   <ul>    <pre><code>Card card1 = new Card();deck.add(card1);</code></pre>  </ul>  <p> This pattern is described more fully in the complete <a href="/patterns/LinearIndexDS.shtml">Linear     Indexed Data Structure Pattern</a>. </ul><p><center><table width="90%" border=1><tr><td><H4>Exercise</H4><p><ul>          <li>Construct three new fish as <a href="#Append">Appended Items</a> in your <code>ArrayList</code>.             Don't forget to pass the aquarium to the <code>AquaFish</code> constructor.         </ul></td></tr></table></center><p><HR><HR><p><a NAME="AccessFish"></a><H2>Viewing the Catch</H2><p><h3>Introduction</h3>Now that we have three fish in a collection, how do we do anything with them? How do we display one of them, or ask one for its color? We can use the <strong>Indexed Random Access</strong> pattern to refer to any individual object in a <a href="#LIDS">Linear Indexed Data Structure</a>. <ul>  <a NAME="IndRanAcc"></a>   <h3><strong>Pattern: Indexed Random Access</strong> (Linear Indexed Data Structure)     -- Abridged</h3>  <p> You want to access (retrieve or set) a specified entry in a <a href="#LinIndDS">Linear     Indexed Data Structure</a>.   <p> <strong>Therefore</strong>, access it directly, specifying the index of     the desired entry. The index should be a <a href="#ValInd">Valid Index</a>     for the specific <a href="#LinIndDS">Linear Indexed Data Structure</a>.   <p> For example, if <code>deck</code> is a Java <code>ArrayList</code> of playing     cards, then one might use the following statement to display the 1st card     in the deck (provided that there is at least 1 card in the deck):   <ul>    <pre><code>((Card)deck.get(0)).display();</code></pre>  </ul>  One could display the 6th card just as easily (provided that there are at least   6 cards in the deck):   <ul>    <pre><code>((Card)deck.get(5)).display();</code></pre>  </ul>  (Note that indexing of <strong>Linear Indexed Data Structures</strong> in C,   C++, and Java, along with some other languages, begins at 0. See <a href="#ValInd">Valid   Index</a> for more details.)   <p> This pattern can also be used to modify an element in the data structure.     For example, to swap the 1st and 52nd cards in the deck, the following code     might be used:   <ul>    <pre><code>Card temp = (Card)deck.get(0);&nbsp;&nbsp; // temp is 1st carddeck.set(0, deck.get(51));       // 1st card is now same as 52nd carddeck.set(temp, 51);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 52nd card is now old 1st card</code></pre>  </ul>  Because a Java container does not require you to specify the type of its elements   at creation (as does a C++ container, for example), you must cast each element   to the appropriate type as you remove it from the container in order to be able   to use it as an object of that type. For example, in the statement below, the   element in the deck must be cast to a <code>Card</code> object before invoking   the <code>display</code> method associated with a card.   <ul>    <pre><code>((Card)deck.get(5)).display();</code></pre>  </ul>  The type in the cast must match the object's actual type or the compiler will   produce a run-time error.   <p>   <hr WIDTH="80%">  <p> <a NAME="ValInd"></a>   <h3><strong>Pattern: Valid Index</strong> (Linear Indexed Data Structure) --     Abridged</h3>  <p> You want to access a valid element in a <a href="#LinIndDS">Linear Indexed     Data Structure</a>.   <p> <strong>Therefore</strong>, use an index in the range determined by the     programming language and the size of the data structure. In many languages,     such as C, C++, and Java, valid indices for a structure with N elements range     from 0 to N-1, where 0 is the index of the 1st element in the <a href="#LinIndDS">Linear     Indexed Data Structure</a> and N-1 is the index of the last element. In other     languages, such as Pascal, valid indices for a <a href="#LinIndDS">Linear     Indexed Data Structure</a> with N elements range from 1 to N.   <p> How to determine the size of a data structure (the number of elements in     it) also depends on the language and the particular data structure. For example,     if your data structure <tt>A</tt> is a Java <code>ArrayList</code>, then you     can use   <ul>    <pre><tt><font color="#0000FF">A.size()</font></tt></pre>  </ul>  to obtain the number of elements.   <p> These patterns are described more fully in the complete <a href="/patterns/LinearIndexDS.shtml">Linear     Indexed Data Structure Pattern</a>. </ul><p><center><table width="90%" border=1><tr><td><H4>Exercise</H4>        <ul>          <li>Display each of the fish in your <code>ArrayList</code> using the             <a href="#IndRanAcc">Indexed Random Access</a> pattern. You may leave             the code for moving the fish commented out for now.             <p>           <li>Test your program to make sure that your program is correctly constructing             and displaying three fish.         </ul>       </td></tr></table></center><p><HR><HR><p><a NAME="ProcessAll"></a><H2>Loopy Fish</H2><p><h3>Introduction</h3><font color="#000000">One of the reasons we switched to using a collection object was to avoid having to duplicate code for each fish, but we currently have three lines to display the three fish.&nbsp; This will not scale up well if we want to put 25 fish in the aquarium!&nbsp; We can access all of the fish sequentially using the <a href="#LinIndTrav">Linear Indexed Traversal</a> pattern.</font> <ul>  <a NAME="LinIndTrav"></a>   <h3><strong>Linear Indexed Traversal</strong> (Repetition) -- Abridged</h3>  <p> You need to access (set or retrieve) all entries of a <a href="#LinIndDS">Linear     Indexed Data Structure</a> exactly once, and, if the order matters, from first     to last. You know the number of elements in the <a href="/patterns/LinearIndexDS.shtml#LinIndDS">Linear     Indexed Data Structure</a>.   <p> <strong>Therefore</strong>, use a FOR statement in which the loop control     variable is a <a href="#ValInd">Valid Index</a> into the linear data structure.     The variable should be initialized to the index of the first element in the     linear data structure, the step should increment the index by one, and the     test should make sure that the index is not used in the loop body if it goes     beyond the last element in the data structure.   <p> The common idiom for <strong>Linear Indexed Traversal</strong> to ensure     a <a href="#ValInd">Valid Index</a> in a Java <code>ArrayList</code>, <code>A</code>,     is   <ul>    <pre><code>for (int i = 0; i &lt; A.size(); i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // body of loop accesses or sets the element at index i in A}</code></pre>  </ul>  For example, if <code>hand</code> is a Java <code>ArrayList</code> of playing   cards, then one might use the following loop to display the cards in the hand:   <ul>    <pre><code>for (int i = 0; i &lt; hand.size(); i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Card)hand.get(i)).displayCard();}</code></pre>  </ul>  <p> This pattern could also be used to modify elements in the collection. For     example, to replace existing cards in the hand with new cards obtained from     a CardDeck object, <code>deck</code>, the following Java code might be used:   <ul>    <pre><code>for (int i = 0; i &lt; hand.size(); i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hand.set(i, deck.dealCard());}</code></pre>  </ul>  <p> Note the condition in the FOR loop: <code>i &lt; N</code> (or, in this case,     <code>i &lt; hand.size()</code>). This is the common idiom in C-based languages     to ensure that the index <code>i</code> is always a <a href="#ValInd">Valid     Index</a> inside the loop. Another, logically equivalent, condition would     be <code>i &lt;= N-1</code>, but the common idiom is more succinct, possibly     more efficient (depending on your compiler), and draws attention more clearly     to the number of elements in the structure (<code>N</code>).   <p>   <ul>    <strong>WARNING:</strong> It is important to note that your loop will have     an <i>off-by-one</i> boundary error if you mix the logical expression of one     condition with the stopping point of the other. If, for example, you write     <ul>      <pre><code>for (int i = 0; i &lt;= hand.size(); i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#FF0000">INCORRECT!</font>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Card)hand.get(i)).displayCard();}</code></pre>    </ul>    you will attempt to display one card too many, going beyond the range of the     data structure. If, on the other hand, you write     <ul>      <pre><code>for (int i = 0; i &lt; hand.size() - 1; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#FF0000">INCORRECT!</font>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Card)hand.get(i)).displayCard();}</code></pre>    </ul>    you will not display the last card. To avoid these kinds of errors, consistently     use the common idiom for <strong>Linear Indexed Traversal</strong>:     <ul>      <code>(i = 0; i &lt; N; i++)</code>     </ul>  </ul>  <p> See <a href="/patterns/Repetition.shtml#RevLinIndTrav">Reverse Linear Indexed     Traversal</a> if you need to access all the entries of an indexed data structure     from last to first. This alternative, and other types of Repetition, are described     in the complete <a href="/patterns/Repetition.shtml">Repetition Pattern</a>.     <!-- This alternative is described in the complete <a href="#IterRep">IterativeRepetition</a> pattern.--></ul><p><center><table width="90%" border=1><tr><td><H4>Exercise</H4><p>        <ul>          <li>Replace your code from the last exercise (where you displayed each             fish individually) with a <a href="#LinIndTrav">Linear Indexed Traversal</a>             to display the fish.             <p>           <li>Now that your code to display fish will handle however many fish             are in the aquarium, it's time to let the user decide how many fish             there should be. Prompt the user for the number of fish to put in             the aquarium and then use the <a href="RepetitionLabs.shtml#CountedRep">Counted             Repetition</a> pattern to construct that number of fish in your <code>ArrayList</code>.             (Question: Where in the program should your prompt appear?) Even though             you are adding new functionality to your program, it should be getting             considerably shorter!             <p>           <li>Test your program to make sure that it correctly constructs and             displays the number of fish specified by the user. Remember that you             may need to drag the display window to the side to see your prompt             for the number of fish.         </ul></td></tr></table></center><p><HR><HR><p><a NAME="School in Motion"></a><H2>A School In Motion</H2><p><h3>Introduction</h3>Now let's think about how to move and display all the fish for as manytime steps as the user wants.&nbsp;<!-- Should have patterns for independent vs nested loops here!!! --><p>It seems clear that we will want to loop through the steps in the simulation,as we are already doing. It also seems clear that we will want to loopthrough all the fish. The question is:<ul><li>Should we do one after the other? If so, which should we do first?<li>Or, should we do one as part of (inside) the other? If so, which goes insidewhich?</ul>Processing all the fish and all the steps in the simulation are<strong>not</strong>independent of one another. That is, we can't process all the fish andthen process all the simulation steps, or<i>vice versa</i>. Either processingall the fish is part of what we do in one step of the simulation, or runningall the steps of the simulation is part of what we do for each fish. Thus,we will need to<strong><i>nest</i></strong> one of the loops inside the other.<p>To decide which loop gets nested inside of which, consider the followingalgorithmic structures in which we assume that we have 25 fish in the aquariumand we want to run the simulation 100 times.<center><table BORDER CELLPADDING=10 ><tr><td VALIGN=TOP>For each fish in the collection:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move 100 times and displaythe aquarium.</td><td VALIGN=TOP>For each step in the simulation:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move the 25 fish once anddisplay the aquarium.</td></tr></table></center><p>We do not want the first fish to move 100 times, followed by the secondfish moving 100 times, followed by the third fish moving 100 times. Instead,we want all 25 fish to move once, then all 25 fish to move again. Thiscorresponds to the second solution above.<p>Another question we have to consider is where the display of the aquariumshould be relative to the fish movement. Do we want to display the fishand aquarium in the outer loop (as part of each simulation step), or inthe inner loop (as part of processing each fish)? The following table illustratesthese two options.<center><table BORDER CELLPADDING=10 ><tr><td VALIGN=TOP>For each step in the simulation:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For each fish in the collection:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move, possibly changing direction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display aquarium &amp; fish.</td><td VALIGN=TOP>For each step in the simulation:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For each fish in the collection:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move, possibly changing direction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display aquarium &amp; fish.</td></tr></table></center><p>Which behavior do you wish to implement?<p><center><table width="90%" border=1><tr><td><H4>Exercise</H4>        <p>		<ul>          <li>Remove the remaining comments around the code that runs through             the steps of the simulation, moving and displaying the fish in the             aquarium.             <p>           <li>Inside the simulation loop, replace the code that moves the three             named fish with a loop that will move all the fish in your collection.             (Each will still change direction when it has to or when it randomly             chooses to.) Use a <a href="#LinIndTrav">Linear Indexed Traversal</a>             through your <a href="#LinIndDS">Linear Indexed Data Structure</a>             of fish. You may wish to create a temporary variable in the loop to             refer to the fish being processed in this iteration rather than repeatedly             retrieve the same fish from the <code>ArrayList</code>.             <p>           <li>Display all the fish in the aquarium with a single statement.&nbsp;             Research the <a href="Code/JavaDocs/AquaView.html">AquaView</a> specification             to discover how to display an indexed collection of fish. Note that             this method will also display the aquarium and pause, so you no longer             need to do that separately. Where does this statement belong? Should             it be part of the inner or outer loop?             <p>           <li>Update the initial display of fish in the aquarium also to display             all the fish at once.             <p>           <li>Test your modifications.        </ul>      </td></tr></table></center><p><HR><HR><br><i><font size=-2>Copyright Alyce Faulstich Brady, 2001.</font></i> </body></html>